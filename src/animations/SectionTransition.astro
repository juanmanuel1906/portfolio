<svg class="shape-overlays z-9" viewBox="0 0 100 100" preserveAspectRatio="none">
    <defs>
        <!--    orange crush -->
        <linearGradient id="gradient1" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" stop-color="#1858D9"></stop>
            <stop offset="100%" stop-color="#1243A6"></stop>
        </linearGradient>
        <!--     svg  gradient -->
        <linearGradient id="gradient2" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" stop-color="#0E2759"></stop>
            <stop offset="100%" stop-color="#1858D9"></stop>
        </linearGradient>
    </defs>
    <path class="shape-overlays__path" fill="url(#gradient2)"></path>
    <path class="shape-overlays__path" fill="url(#gradient1)"></path>
</svg>

<style>
    .shape-overlays {
        width: 100%;
        height: 100%;
        position: fixed;
        top: 0;
        left: 0;
        pointer-events: none;
    }
</style>

<script>
    console.clear();
    import { gsap } from "gsap";

    let overlay: any = document.querySelector(".shape-overlays");
    let paths = document.querySelectorAll(".shape-overlays__path");

    let numPoints = 10;
    let numPaths = paths.length;
    let delayPointsMax = 0.3;
    let delayPerPath = 0.25;
    let duration = 0.9;
    let isOpened = false;
    let pointsDelay: any = [];
    let allPoints: any = [];

    let tl = gsap.timeline({
        onUpdate: render,
        defaults: {
            ease: "power2.inOut",
            duration: 0.9,
        },
    });

    for (let i = 0; i < numPaths; i++) {
        let points: any = [];
        allPoints.push(points);
        for (let j = 0; j < numPoints; j++) {
            points.push(100);
        }
    }

    toggle();

    function onClick() {
        if (!tl.isActive()) {
            isOpened = !isOpened;
            toggle();
        }
    }

    function toggle() {
        tl.progress(0).clear();

        for (let i = 0; i < numPoints; i++) {
            pointsDelay[i] = Math.random() * delayPointsMax;
        }

        for (let i = 0; i < numPaths; i++) {
            let points = allPoints[i];
            let pathDelay = delayPerPath * (isOpened ? i : numPaths - i - 1);

            for (let j = 0; j < numPoints; j++) {
                let delay = pointsDelay[j];
                tl.to(
                    points,
                    {
                        [j]: 0,
                    },
                    delay + pathDelay,
                );
            }
        }
    }

    function render() {
        for (let i = 0; i < numPaths; i++) {
            let path = paths[i];
            let points = allPoints[i];

            let d = "";
            d += isOpened ? `M 0 0 V ${points[0]} C` : `M 0 ${points[0]} C`;

            for (let j = 0; j < numPoints - 1; j++) {
                let p = ((j + 1) / (numPoints - 1)) * 100;
                let cp = p - ((1 / (numPoints - 1)) * 100) / 2;
                d += ` ${cp} ${points[j]} ${cp} ${points[j + 1]} ${p} ${points[j + 1]}`;
            }

            d += isOpened ? ` V 100 H 0` : ` V 0 H 0`;
            path.setAttribute("d", d);
        }
    }
    
</script>
